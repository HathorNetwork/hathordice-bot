/** Declaration file generated by dts-gen */

export class Connection {
    constructor(...args: any[]);

    handleWalletMessage(...args: any[]): void;

    onConnectionChange(...args: any[]): void;

    setState(...args: any[]): void;

    start(...args: any[]): void;

    stop(...args: any[]): void;

    static CLOSED: number;

    static CONNECTED: number;

    static CONNECTING: number;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static init(opts: any): void;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any): any;

    static once(emitter: any, name: any): any;

    static usingDomains: boolean;

}

declare interface _HathorWallet__start {
  version: string;
  network: string;
  min_weight: number;
  min_tx_weight: number;
  min_tx_weight_coefficient: number;
  min_tx_weight_k: number;
  token_deposit_percentage: number;
  reward_spend_min_blocks: number;
  max_number_inputs: number;
  max_number_outputs: number;
}

declare interface _HathorWallet__getBalance {
  available: number;
  locked: number;
}

export class HathorWallet {
    constructor(...args: any[]);

    getBalance(...args: any[]): _HathorWallet__getBalance;

    getCurrentAddress(...args: any[]): string;

    getTokenData(...args: any[]): void;

    getTxBalance(...args: any[]): void;

    getTxHistory(...args: any[]): void;

    handleWebsocketMsg(...args: any[]): void;

    isReady(...args: any[]): void;

    onConnectionChangedState(...args: any[]): void;

    onNewTx(...args: any[]): void;

    prepareTransaction(...args: any[]): void;

    sendMultiTokenTransaction(...args: any[]): void;

    sendPreparedTransaction(...args: any[]): void;

    sendTransaction(...args: any[]): Promise<void>;

    setState(...args: any[]): void;

    start(...args: any[]): Promise<_HathorWallet__start>;

    stop(...args: any[]): void;

    static CLOSED: number;

    static CONNECTING: number;

    static READY: number;

    static SYNCING: number;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static init(opts: any): void;

    static listenerCount(emitter: any, type: any): any;

    on(event: 'state', listener: (event: number) => void): this;
    on(event: string, listener: Function): this;
    once(event: 'state', listener: (event: number) => void): this;
    once(event: string, listener: Function): this;

    static usingDomains: boolean;

}

export class MemoryStore {
    constructor(...args: any[]);

    clear(...args: any[]): void;

    getItem(...args: any[]): void;

    removeItem(...args: any[]): void;

    setItem(...args: any[]): void;

}

export const constants: {
    AUTHORITY_TOKEN_DATA: number;
    BLOCK_VERSION: number;
    CREATE_TOKEN_TX_VERSION: number;
    DECIMAL_PLACES: number;
    DEFAULT_SERVER: string;
    DEFAULT_SERVERS: string[];
    DEFAULT_TX_VERSION: number;
    GAP_LIMIT: number;
    GENESIS_BLOCK: string[];
    GENESIS_TX: string[];
    HASH_ITERATIONS: number;
    HASH_KEY_SIZE: number;
    HATHOR_BIP44_CODE: number;
    HATHOR_TOKEN_CONFIG: {
        name: string;
        symbol: string;
        uid: string;
    };
    HATHOR_TOKEN_INDEX: number;
    HD_WALLET_ENTROPY: number;
    LIMIT_ADDRESS_GENERATION: boolean;
    MAX_OUTPUT_VALUE: number;
    MAX_OUTPUT_VALUE_32: number;
    MERGED_MINED_BLOCK_VERSION: number;
    MIN_API_VERSION: string;
    SEND_TOKENS_TIMEOUT: number;
    STRATUM_TIMEOUT_RETURN_CODE: string;
    TIMEOUT: number;
    TOKEN_AUTHORITY_MASK: number;
    TOKEN_INDEX_MASK: number;
    TOKEN_INFO_VERSION: number;
    TOKEN_MELT_MASK: number;
    TOKEN_MINT_MASK: number;
};

export namespace Connection {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static init(opts: any): void;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any): any;

        static once(emitter: any, name: any): any;

        static usingDomains: boolean;

    }

}

export namespace HathorWallet {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static init(opts: any): void;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any): any;

        static once(emitter: any, name: any): any;

        static usingDomains: boolean;

    }

}

export namespace WebSocketHandler {
    const ws: any;

    function addListener(type: any, listener: any): any;

    function emit(type: any, args: any): any;

    function endConnection(...args: any[]): void;

    function eventNames(): any;

    function getMaxListeners(): any;

    function handleIsOnline(...args: any[]): void;

    function listenerCount(type: any): any;

    function listeners(type: any): any;

    function off(type: any, listener: any): any;

    function on(type: any, listener: any): any;

    function once(type: any, listener: any): any;

    function prependListener(type: any, listener: any): any;

    function prependOnceListener(type: any, listener: any): any;

    function rawListeners(type: any): any;

    function removeAllListeners(type: any, ...args: any[]): any;

    function removeListener(type: any, listener: any): any;

    function setMaxListeners(n: any): any;

    function setup(...args: any[]): void;

}

export namespace axios {
    function createRequestInstance(resolve: any, timeout: any): any;

    function defaultCreateRequestInstance(resolve: any, timeout: any): any;

    function registerNewCreateRequestInstance(fn: any): void;

}

export namespace dateFormatter {
    function dateToTimestamp(...args: any[]): void;

    function parseTimestamp(...args: any[]): void;

    function uptimeFormat(...args: any[]): void;

}

export namespace errors {
    function AddressError(...args: any[]): void;

    function ConstantNotSet(...args: any[]): void;

    function CreateTokenTxInvalid(...args: any[]): void;

    function InsufficientFundsError(...args: any[]): void;

    function MaximumNumberInputsError(...args: any[]): void;

    function MaximumNumberOutputsError(...args: any[]): void;

    function OutputValueError(...args: any[]): void;

    function TokenValidationError(...args: any[]): void;

    function WalletTypeError(...args: any[]): void;

    namespace AddressError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace ConstantNotSet {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace CreateTokenTxInvalid {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace InsufficientFundsError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace MaximumNumberInputsError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace MaximumNumberOutputsError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace OutputValueError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace TokenValidationError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

    namespace WalletTypeError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

}

export namespace helpers {
    function cleanupString(...args: any[]): void;

    function elementCount(...args: any[]): void;

    function fixAxiosConfig(...args: any[]): void;

    function getCleanVersionArray(...args: any[]): void;

    function getServerURL(...args: any[]): void;

    function getShortHash(...args: any[]): void;

    function getTxType(...args: any[]): void;

    function getWSServerURL(...args: any[]): void;

    function isBlock(...args: any[]): void;

    function isVersionAllowed(...args: any[]): void;

    function minimumAmount(...args: any[]): void;

    function plural(...args: any[]): void;

    function prettyValue(...args: any[]): void;

    function roundFloat(...args: any[]): void;

    function updateListWs(...args: any[]): void;

}

export namespace network {
    const network: string;

    const networkOptions: {
        mainnet: {
            alias: string;
            dnsSeeds: any[];
            name: string;
            networkMagic: {
                "0": number;
                "1": number;
                "2": number;
                "3": number;
                BYTES_PER_ELEMENT: number;
                asciiSlice: any;
                asciiWrite: any;
                base64Slice: any;
                base64Write: any;
                buffer: {
                    byteLength: number;
                    slice: any;
                };
                byteLength: number;
                byteOffset: number;
                compare: any;
                copy: any;
                copyWithin: any;
                entries: any;
                equals: any;
                every: any;
                fill: any;
                filter: any;
                find: any;
                findIndex: any;
                forEach: any;
                hexSlice: any;
                hexWrite: any;
                includes: any;
                indexOf: any;
                inspect: any;
                join: any;
                keys: any;
                lastIndexOf: any;
                latin1Slice: any;
                latin1Write: any;
                length: number;
                map: any;
                offset: number;
                parent: {
                    byteLength: number;
                    slice: any;
                };
                readBigInt64BE: any;
                readBigInt64LE: any;
                readBigUInt64BE: any;
                readBigUInt64LE: any;
                readDoubleBE: any;
                readDoubleLE: any;
                readFloatBE: any;
                readFloatLE: any;
                readInt16BE: any;
                readInt16LE: any;
                readInt32BE: any;
                readInt32LE: any;
                readInt8: any;
                readIntBE: any;
                readIntLE: any;
                readUInt16BE: any;
                readUInt16LE: any;
                readUInt32BE: any;
                readUInt32LE: any;
                readUInt8: any;
                readUIntBE: any;
                readUIntLE: any;
                reduce: any;
                reduceRight: any;
                reverse: any;
                set: any;
                slice: any;
                some: any;
                sort: any;
                subarray: any;
                swap16: any;
                swap32: any;
                swap64: any;
                toJSON: any;
                toLocaleString: any;
                toString: any;
                ucs2Slice: any;
                ucs2Write: any;
                utf8Slice: any;
                utf8Write: any;
                values: any;
                write: any;
                writeBigInt64BE: any;
                writeBigInt64LE: any;
                writeBigUInt64BE: any;
                writeBigUInt64LE: any;
                writeDoubleBE: any;
                writeDoubleLE: any;
                writeFloatBE: any;
                writeFloatLE: any;
                writeInt16BE: any;
                writeInt16LE: any;
                writeInt32BE: any;
                writeInt32LE: any;
                writeInt8: any;
                writeIntBE: any;
                writeIntLE: any;
                writeUInt16BE: any;
                writeUInt16LE: any;
                writeUInt32BE: any;
                writeUInt32LE: any;
                writeUInt8: any;
                writeUIntBE: any;
                writeUIntLE: any;
            };
            port: number;
            privatekey: number;
            pubkeyhash: number;
            scripthash: number;
            toString: any;
            xprivkey: number;
            xpubkey: number;
        };
        testnet: {
            alias: string;
            dnsSeeds: any[];
            name: string;
            networkMagic: {
                "0": number;
                "1": number;
                "2": number;
                "3": number;
                BYTES_PER_ELEMENT: number;
                asciiSlice: any;
                asciiWrite: any;
                base64Slice: any;
                base64Write: any;
                buffer: {
                    byteLength: number;
                    slice: any;
                };
                byteLength: number;
                byteOffset: number;
                compare: any;
                copy: any;
                copyWithin: any;
                entries: any;
                equals: any;
                every: any;
                fill: any;
                filter: any;
                find: any;
                findIndex: any;
                forEach: any;
                hexSlice: any;
                hexWrite: any;
                includes: any;
                indexOf: any;
                inspect: any;
                join: any;
                keys: any;
                lastIndexOf: any;
                latin1Slice: any;
                latin1Write: any;
                length: number;
                map: any;
                offset: number;
                parent: {
                    byteLength: number;
                    slice: any;
                };
                readBigInt64BE: any;
                readBigInt64LE: any;
                readBigUInt64BE: any;
                readBigUInt64LE: any;
                readDoubleBE: any;
                readDoubleLE: any;
                readFloatBE: any;
                readFloatLE: any;
                readInt16BE: any;
                readInt16LE: any;
                readInt32BE: any;
                readInt32LE: any;
                readInt8: any;
                readIntBE: any;
                readIntLE: any;
                readUInt16BE: any;
                readUInt16LE: any;
                readUInt32BE: any;
                readUInt32LE: any;
                readUInt8: any;
                readUIntBE: any;
                readUIntLE: any;
                reduce: any;
                reduceRight: any;
                reverse: any;
                set: any;
                slice: any;
                some: any;
                sort: any;
                subarray: any;
                swap16: any;
                swap32: any;
                swap64: any;
                toJSON: any;
                toLocaleString: any;
                toString: any;
                ucs2Slice: any;
                ucs2Write: any;
                utf8Slice: any;
                utf8Write: any;
                values: any;
                write: any;
                writeBigInt64BE: any;
                writeBigInt64LE: any;
                writeBigUInt64BE: any;
                writeBigUInt64LE: any;
                writeDoubleBE: any;
                writeDoubleLE: any;
                writeFloatBE: any;
                writeFloatLE: any;
                writeInt16BE: any;
                writeInt16LE: any;
                writeInt32BE: any;
                writeInt32LE: any;
                writeInt8: any;
                writeIntBE: any;
                writeIntLE: any;
                writeUInt16BE: any;
                writeUInt16LE: any;
                writeUInt32BE: any;
                writeUInt32LE: any;
                writeUInt8: any;
                writeUIntBE: any;
                writeUIntLE: any;
            };
            port: number;
            privatekey: number;
            pubkeyhash: number;
            scripthash: number;
            toString: any;
            xprivkey: number;
            xpubkey: number;
        };
    };

    const versionBytes: {
        mainnet: {
            p2pkh: number;
            p2sh: number;
        };
        testnet: {
            p2pkh: number;
            p2sh: number;
        };
    };

    function getNetwork(...args: any[]): void;

    function getVersionBytes(...args: any[]): void;

    function setNetwork(...args: any[]): void;

}

export namespace storage {
    const store: any;

    function clear(...args: any[]): void;

    function getItem(...args: any[]): void;

    function preStart(...args: any[]): void;

    function removeItem(...args: any[]): void;

    function setItem(...args: any[]): void;

    function setStore(...args: any[]): void;

}

export namespace tokens {
    function addToken(...args: any[]): void;

    function clearDepositPercentage(...args: any[]): void;

    function createDelegateAuthorityData(...args: any[]): void;

    function createMeltData(...args: any[]): void;

    function createMintData(...args: any[]): void;

    function createToken(...args: any[]): void;

    function delegateAuthority(...args: any[]): void;

    function destroyAuthority(...args: any[]): void;

    function editToken(...args: any[]): void;

    function filterTokens(...args: any[]): void;

    function getConfigurationString(...args: any[]): void;

    function getDepositAmount(...args: any[]): void;

    function getDepositPercentage(...args: any[]): void;

    function getMeltInputs(...args: any[]): void;

    function getMintDepositInfo(...args: any[]): void;

    function getTokenFromConfigurationString(...args: any[]): void;

    function getTokenIndex(...args: any[]): void;

    function getTokenUID(...args: any[]): void;

    function getTokens(...args: any[]): void;

    function getWithdrawAmount(...args: any[]): void;

    function isHathorToken(...args: any[]): void;

    function meltTokens(...args: any[]): void;

    function mintTokens(...args: any[]): void;

    function saveToStorage(...args: any[]): void;

    function tokenExists(...args: any[]): void;

    function tokenInfoExists(...args: any[]): void;

    function unregisterToken(...args: any[]): void;

    function updateDepositPercentage(...args: any[]): void;

    function validateTokenToAddByConfigurationString(...args: any[]): void;

    function validateTokenToAddByUid(...args: any[]): void;

}

export namespace transaction {
    function calculateTxWeight(...args: any[]): void;

    function clearMaxInputsConstant(...args: any[]): void;

    function clearMaxOutputsConstant(...args: any[]): void;

    function clearTransactionWeightConstants(...args: any[]): void;

    function completeTx(...args: any[]): void;

    function createInputData(...args: any[]): void;

    function createOutputScript(...args: any[]): void;

    function dataToSign(...args: any[]): void;

    function decodeAddress(...args: any[]): void;

    function floatToBytes(...args: any[]): void;

    function getChecksum(...args: any[]): void;

    function getDataToSignHash(...args: any[]): void;

    function getMaxInputsConstant(...args: any[]): void;

    function getMaxOutputsConstant(...args: any[]): void;

    function getOutputsSum(...args: any[]): void;

    function getSignature(...args: any[]): void;

    function getTransactionWeightConstants(...args: any[]): void;

    function intToBytes(...args: any[]): void;

    function isAddressValid(...args: any[]): void;

    function isTokenDataAuthority(...args: any[]): void;

    function outputValueToBytes(...args: any[]): void;

    function prepareData(...args: any[]): void;

    function pushDataToStack(...args: any[]): void;

    function sendPreparedTransaction(...args: any[]): void;

    function sendTransaction(...args: any[]): void;

    function serializeTokenInfo(...args: any[]): void;

    function setWeightIfNeeded(...args: any[]): void;

    function signTx(...args: any[]): void;

    function signedIntToBytes(...args: any[]): void;

    function txToBytes(...args: any[]): void;

    function updateMaxInputsConstant(...args: any[]): void;

    function updateMaxOutputsConstant(...args: any[]): void;

    function updateTransactionWeightConstants(...args: any[]): void;

    function validateAddress(...args: any[]): void;

    function verifyTxData(...args: any[]): void;

}

export namespace txApi {
    function decodeTx(...args: any[]): void;

    function getConfirmationData(...args: any[]): void;

    function getDashboardTx(...args: any[]): void;

    function getGraphviz(...args: any[]): void;

    function getTransaction(...args: any[]): void;

    function getTransactionBase(...args: any[]): void;

    function getTransactions(...args: any[]): void;

    function pushTx(...args: any[]): void;

}

export namespace version {
    function checkApiVersion(...args: any[]): void;

}

export namespace versionApi {
    function getVersion(...args: any[]): void;

}

export namespace wallet {
    function addMetricsListener(...args: any[]): void;

    function addPassphrase(...args: any[]): void;

    function areInputsMine(...args: any[]): void;

    function calculateBalance(...args: any[]): void;

    function canGenerateNewAddress(...args: any[]): void;

    function canUseUnspentTx(...args: any[]): void;

    function changePin(...args: any[]): void;

    function changeServer(...args: any[]): void;

    function checkUnspentTxExists(...args: any[]): void;

    function cleanLoadedData(...args: any[]): void;

    function cleanServer(...args: any[]): void;

    function cleanWallet(...args: any[]): void;

    function clearDefaultServer(...args: any[]): void;

    function clearNetworkBestChainHeight(...args: any[]): void;

    function clearRewardLockConstant(...args: any[]): void;

    function close(...args: any[]): void;

    function decryptData(...args: any[]): void;

    function encryptData(...args: any[]): void;

    function executeGenerateWallet(...args: any[]): void;

    function filterHistoryTransactions(...args: any[]): void;

    function generateNewAddress(...args: any[]): void;

    function generateWalletWords(...args: any[]): void;

    function getAddressToUse(...args: any[]): void;

    function getCurrentAddress(...args: any[]): void;

    function getInputsFromAmount(...args: any[]): void;

    function getLastGeneratedIndex(...args: any[]): void;

    function getLastSharedIndex(...args: any[]): void;

    function getLastUsedIndex(...args: any[]): void;

    function getLocalStorageIndex(...args: any[]): void;

    function getNetworkHeight(...args: any[]): void;

    function getNextAddress(...args: any[]): void;

    function getOutputChange(...args: any[]): void;

    function getPublicKey(...args: any[]): void;

    function getRewardLockConstant(...args: any[]): void;

    function getTokenIndex(...args: any[]): void;

    function getTxBalance(...args: any[]): void;

    function getTxHistory(...args: any[]): void;

    function getWalletAccessData(...args: any[]): void;

    function getWalletData(...args: any[]): void;

    function getWalletTypePretty(...args: any[]): void;

    function getWalletWords(...args: any[]): void;

    function handleWebsocketDashboard(...args: any[]): void;

    function hasNewAddress(...args: any[]): void;

    function hasTokenAndAddress(...args: any[]): void;

    function hashPassword(...args: any[]): void;

    function hashValidation(...args: any[]): void;

    function isAddressMine(...args: any[]): void;

    function isAuthorityOutput(...args: any[]): void;

    function isBackupDone(...args: any[]): void;

    function isHardwareWallet(...args: any[]): void;

    function isLocked(...args: any[]): void;

    function isMeltOutput(...args: any[]): void;

    function isMintOutput(...args: any[]): void;

    function isPasswordCorrect(...args: any[]): void;

    function isPinCorrect(...args: any[]): void;

    function isSoftwareWallet(...args: any[]): void;

    function loadAddressHistory(...args: any[]): void;

    function loaded(...args: any[]): void;

    function lock(...args: any[]): void;

    function markBackupAsDone(...args: any[]): void;

    function markBackupAsNotDone(...args: any[]): void;

    function markWalletAsStarted(...args: any[]): void;

    function nextAddress(...args: any[]): void;

    function oldHashPassword(...args: any[]): void;

    function onWebsocketBeforeClose(...args: any[]): void;

    function onWebsocketOpened(...args: any[]): void;

    function prepareSendTokensData(...args: any[]): void;

    function reloadData(...args: any[]): void;

    function removeMetricsListener(...args: any[]): void;

    function resetAllData(...args: any[]): void;

    function resetWalletData(...args: any[]): void;

    function saveAddressHistory(...args: any[]): void;

    function saveNewHistoryOnStorage(...args: any[]): void;

    function setDefaultServer(...args: any[]): void;

    function setLastUsedIndex(...args: any[]): void;

    function setWalletAccessData(...args: any[]): void;

    function setWalletAsOpen(...args: any[]): void;

    function setWalletData(...args: any[]): void;

    function setWalletType(...args: any[]): void;

    function startWallet(...args: any[]): void;

    function started(...args: any[]): void;

    function subscribeAddress(...args: any[]): void;

    function subscribeAllAddresses(...args: any[]): void;

    function toPubkeyCompressed(...args: any[]): void;

    function txExists(...args: any[]): void;

    function unlock(...args: any[]): void;

    function unsubscribeAddress(...args: any[]): void;

    function unsubscribeAllAddresses(...args: any[]): void;

    function updateAddress(...args: any[]): void;

    function updateHistoryData(...args: any[]): void;

    function updateNetworkHeight(...args: any[]): void;

    function updateRewardLockConstant(...args: any[]): void;

    function wasClosed(...args: any[]): void;

    function wordsValid(...args: any[]): void;

    function xpubFromData(...args: any[]): void;

}

export namespace walletApi {
    function getAddressBalance(...args: any[]): void;

    function getAddressHistory(...args: any[]): void;

    function getAddressHistoryForAwait(...args: any[]): void;

    function getGeneralTokenInfo(...args: any[]): void;

    function getMiningInfo(...args: any[]): void;

    function getSearchAddress(...args: any[]): void;

    function getTokenHistory(...args: any[]): void;

    function getTokensList(...args: any[]): void;

    function sendTokens(...args: any[]): void;

}

